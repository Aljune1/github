<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vending Machine Dashboard</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Add Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-auth-compat.js"></script>
    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #3498db;
            --light: #ecf0f1;
            --dark: #1a252f;
            --success: #2ecc71;
            --danger: #e74c3c;
            --warning: #f39c12;
            --border-radius: 12px;
            --box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }

        body {
            background-color: #f8fafc;
            color: var(--primary);
            line-height: 1.6;
            display: flex;
            min-height: 100vh;
            scroll-behavior: smooth;
        }

        .sidebar {
            width: 250px;
            background-color: var(--primary);
            color: white;
            padding: 25px 20px;
            height: 100vh;
            position: fixed;
            box-shadow: 2px 0 20px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .sidebar h2 {
            font-weight: 600;
            font-size: 1.5rem;
        }

        .sidebar-close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 1.8rem;
            cursor: pointer;
            display: none;
            padding: 5px;
            transition: all 0.3s;
        }

        .sidebar-close-btn:hover {
            color: var(--secondary);
            transform: scale(1.1);
        }

        .sidebar-menu {
            list-style: none;
            flex: 1;
        }

        .sidebar-menu li {
            margin-bottom: 12px;
        }

        .sidebar-menu a {
            color: white;
            text-decoration: none;
            display: flex;
            align-items: center;
            padding: 12px 15px;
            border-radius: var(--border-radius);
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .sidebar-menu a:hover {
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--light);
        }

        .sidebar-menu a.active {
            background-color: var(--secondary);
            color: white;
        }

        .sidebar-menu i {
            margin-right: 12px;
            width: 20px;
            text-align: center;
            font-size: 1.1rem;
        }

        .sidebar-footer {
            margin-top: auto;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.85rem;
            text-align: center;
        }

        .main-content {
            flex: 1;
            margin-left: 250px;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 25px;
        }


        /* Updated header styles for sticky behavior */
        header {
    background-color: var(--primary) !important; /* Dark blue like sidebar */
    color: white !important; /* Text color white for contrast */
    padding: 15px 0;
    box-shadow: 0 2px 15px rgba(0, 0, 0, 0.05);
    border-bottom: 1px solid rgba(0, 0, 0, 0.05);
    position: sticky;
    top: 0;
    z-index: 90;
    width: 100%;
}

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 15px;
        }

        /* Ensure header elements stay aligned */
        .header-title-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        h1 {
            font-size: 1.4rem;
            font-weight: 600;
            margin: 0;
            white-space: nowrap;
        }
        /* Updated Hamburger Menu - Hover Only Animation */
.hamburger-menu {
    background: none;
    border: none;
    color: white !important;
    font-size: 1.5rem;
    cursor: pointer;
    padding: 5px;
    display: none; /* Hidden by default */
    margin-right: 15px;
    position: relative;
    width: 36px;
    height: 36px;
    border-radius: 4px;
    transition: all 0.3s ease;
    z-index: 101;
}

.hamburger-menu .hamburger-icon {
    display: block;
    position: relative;
    width: 24px;
    height: 2px;
    background: white;
    margin: 6px auto;
    transition: all 0.3s ease;
}

.hamburger-menu .hamburger-icon::before,
.hamburger-menu .hamburger-icon::after {
    content: '';
    position: absolute;
    width: 24px;
    height: 2px;
    background: white;
    left: 0;
    transition: all 0.3s ease;
}

.hamburger-menu .hamburger-icon::before {
    top: -8px;
}

.hamburger-menu .hamburger-icon::after {
    bottom: -8px;
}

/* Hover effects - transforms into X */
.hamburger-menu:hover .hamburger-icon {
    background: transparent;
}

.hamburger-menu:hover .hamburger-icon::before {
    transform: translateY(8px) rotate(45deg);
}

.hamburger-menu:hover .hamburger-icon::after {
    transform: translateY(-8px) rotate(-45deg);
}

/* Make sure it's visible on mobile */
@media (max-width: 576px) {
    .hamburger-menu {
        display: block;
    }
}

        .user-menu {
            position: relative;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        
        .user-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--secondary);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1.2rem;
            border: 2px solid rgba(255, 255, 255, 0.2);
            overflow: hidden; /* Ensure the image stays within the circle */
            position: relative; /* Added for loading indicator positioning */
        }
         /* Modern loading animation for user icon */
.user-icon.loading {
    position: relative;
    overflow: hidden;
    background-color: rgba(52, 152, 219, 0.2); /* Semi-transparent version of the main color */
}

.user-icon.loading::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 24px;
    height: 24px;
    margin: -12px 0 0 -12px;
    border: 3px solid transparent;
    border-top-color: white;
    border-radius: 50%;
    animation: spin 0.8s cubic-bezier(0.5, 0.1, 0.4, 0.9) infinite;
    z-index: 2;
    box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
}

.user-icon.loading::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: radial-gradient(circle, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0) 70%);
    border-radius: 50%;
}

.user-icon.loading i {
    opacity: 0.3;
    transform: scale(0.8);
    transition: all 0.3s ease;
}

@keyframes spin {
    0% { transform: translate(-50%, -50%) rotate(0deg); }
    100% { transform: translate(-50%, -50%) rotate(360deg); }
}
        .user-icon:hover {
            background-color: var(--dark);
            transform: scale(1.05);
        }

        .dropdown-content {
            display: none;
            position: absolute;
            right: 0;
            background-color: white;
            min-width: 180px;
            box-shadow: var(--box-shadow);
            border-radius: var(--border-radius);
            z-index: 1;
            overflow: hidden;
            top: 100%;
            margin-top: 10px;
        }

        .dropdown-content.show {
            display: block;
        }

        .dropdown-content a {
            color: var(--primary);
            padding: 12px 16px;
            text-decoration: none;
            display: block;
            transition: all 0.3s;
            font-size: 0.95rem;
        }

        .dropdown-content a:hover {
            background-color: rgba(52, 152, 219, 0.1);
            color: var(--secondary);
        }

        .dropdown-content i {
            margin-right: 10px;
            width: 18px;
        }

        .dashboard-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 25px;
    width: 100%;
}

.dashboard-header h2 {
    font-size: 1.2rem;
    font-weight: 600;
    color: var(--primary);
    white-space: nowrap;
    margin: 0;
    padding: 0;
    line-height: 1.2;
}

        /* Updated button styles */
        .btn {
            padding: 8px 12px;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            font-size: 0.85rem;
            height: 32px; /* Fixed height */
            line-height: 1; /* Remove extra line height */
            white-space: nowrap;
        }

        .btn i {
            font-size: 0.7rem;
            margin-right: 5px;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .dashboard-header {
                gap: 10px;
            }
            
            .dashboard-header h2 {
                font-size: 1.1rem;
            }
            
            .btn {
                padding: 6px 10px;
                font-size: 0.8rem;
                height: 30px;
            }
        }

        @media (max-width: 480px) {
            .dashboard-header {
                gap: 8px;
            }
            
            .dashboard-header h2 {
                font-size: 1rem;
            }
            
            .btn {
                padding: 5px 8px;
                font-size: 0.75rem;
                height: 28px;
            }
            
            .btn i {
                margin-right: 3px;
                font-size: 0.6rem;
            }
        }

        .btn-primary {
            background-color: var(--secondary);
            color: white;
        }

        .btn-primary:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .search-bar {
            display: flex;
            margin-bottom: 25px;
            background-color: white;
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--box-shadow);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .search-bar input {
            flex: 1;
            padding: 12px 18px;
            border: none;
            font-size: 1rem;
            outline: none;
            transition: all 0.3s;
        }

        .search-bar input:focus {
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
        }

        .search-bar button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 12px 18px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .search-bar button:hover {
            background-color: var(--dark);
        }

        .products-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 25px;
        }

        /* Modern Card Design */
        .product-card {
            background-color: white;
            color: var(--primary);
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.05);
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            border: 1px solid rgba(0, 0, 0, 0.03);
            position: relative;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .product-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            border-color: rgba(52, 152, 219, 0.2);
        }

        .product-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--secondary), #4ecdc4);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .product-card:hover::before {
            opacity: 1;
        }

        .product-info {
            padding: 22px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .product-name {
            font-weight: 600;
            margin-bottom: 12px;
            font-size: 1.15rem;
            color: var(--primary);
            line-height: 1.4;
        }

        .product-meta {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            align-items: center;
        }

        .product-quantity {
            color: var(--primary);
            opacity: 0.85;
            font-size: 0.92rem;
            display: flex;
            align-items: center;
            background: rgba(0, 0, 0, 0.02);
            padding: 6px 10px;
            border-radius: 20px;
        }

        .product-price {
            font-weight: 700;
            color: var(--primary);
            font-size: 1.25rem;
            letter-spacing: -0.5px;
        }

        .product-actions {
            display: flex;
            justify-content: space-between;
            gap: 12px;
            margin-top: auto;
        }

        .btn-edit {
            background-color: rgba(52, 152, 219, 0.08);
            color: var(--secondary);
            flex: 1;
            border: 1px solid rgba(52, 152, 219, 0.15);
            transition: all 0.2s ease;
        }

        .btn-edit:hover {
            background-color: var(--secondary);
            color: white;
            border-color: var(--secondary);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(52, 152, 219, 0.2);
        }

        .btn-delete {
            background-color: rgba(231, 76, 60, 0.08);
            color: var(--danger);
            flex: 1;
            border: 1px solid rgba(231, 76, 60, 0.15);
            transition: all 0.2s ease;
        }

        .btn-delete:hover {
            background-color: var(--danger);
            color: white;
            border-color: var(--danger);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(231, 76, 60, 0.2);
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.8);
            position: relative;
        }

        .status-indicator::after {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            border-radius: 50%;
            opacity: 0.3;
        }

        .status-available {
            background-color: var(--success);
        }

        .status-available::after {
            background-color: var(--success);
        }

        .status-low {
            background-color: var(--warning);
        }

        .status-low::after {
            background-color: var(--warning);
        }

        .status-out {
            background-color: var(--danger);
        }

        .status-out::after {
            background-color: var(--danger);
        }

    /* Modal styles - Responsive */
.modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    z-index: 1000;
    justify-content: center;
    align-items: center;
    backdrop-filter: blur(5px);
    padding: 20px;
    box-sizing: border-box;
    overflow-y: auto;
}

.modal-content {
    background-color: white;
    padding: 30px;
    border-radius: var(--border-radius);
    width: 100%;
    max-width: 500px;
    box-shadow: var(--box-shadow);
    transform: translateY(20px);
    opacity: 0;
    transition: all 0.3s ease;
    margin: auto;
    max-height: 90vh;
    overflow-y: auto;
}

.modal.show .modal-content {
    transform: translateY(0);
    opacity: 1;
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 25px;
    padding-bottom: 15px;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
}

.modal-title {
    font-size: 1.4rem;
    font-weight: 600;
    color: var(--primary);
}

.close-btn {
    background: none;
    border: none;
    font-size: 1.5rem;
    cursor: pointer;
    color: #64748b;
    transition: all 0.3s;
    padding: 5px;
}

.close-btn:hover {
    color: var(--danger);
    transform: rotate(90deg);
}

.form-group {
    margin-bottom: 20px;
}

.form-group label {
    display: block;
    margin-bottom: 8px;
    font-weight: 500;
    color: var(--primary);
    font-size: 0.95rem;
}

.form-group input,
.form-group select {
    width: 100%;
    padding: 12px 15px;
    border: 1px solid #e2e8f0;
    border-radius: var(--border-radius);
    font-size: 1rem;
    transition: all 0.3s;
    box-sizing: border-box;
}

.form-group input:focus,
.form-group select:focus {
    border-color: var(--secondary);
    box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
    outline: none;
}

.modal-actions {
    display: flex;
    justify-content: flex-end;
    gap: 12px;
    margin-top: 25px;
    flex-wrap: wrap;
}

.btn-cancel {
    background-color: #f1f5f9;
    color: #64748b;
}

.btn-cancel:hover {
    background-color: #e2e8f0;
}

.btn-save {
    background-color: var(--secondary);
    color: white;
}

.btn-save:hover {
    background-color: #2980b9;
    transform: translateY(-2px);
}

/* Modern mobile-first responsive adjustments */
@media (max-width: 768px) {
    .modal-content {
        padding: 25px;
    }
    
    .modal-title {
        font-size: 1.3rem;
    }
    
    .form-group input,
    .form-group select {
        padding: 12px;
    }
    
    .modal-actions {
        gap: 10px;
    }
}

@media (max-width: 576px) {
    .modal {
        padding: 15px;
        align-items: flex-start;
        backdrop-filter: blur(3px);
    }
    
    .modal-content {
        padding: 20px;
        margin-top: 20px;
        margin-bottom: 20px;
        border-radius: 16px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
    }
    
    .modal-header {
        margin-bottom: 20px;
        padding-bottom: 12px;
    }
    
    .modal-title {
        font-size: 1.25rem;
    }
    
    .form-group {
        margin-bottom: 18px;
    }
    
    .form-group label {
        font-size: 0.9rem;
    }
    
    .form-group input,
    .form-group select {
        padding: 12px;
        font-size: 0.95rem;
    }
    
    .modal-actions {
        flex-direction: column;
        gap: 10px;
        margin-top: 20px;
    }
    
    .modal-actions .btn {
        width: 100%;
        padding: 12px;
    }
    
    .close-btn {
        font-size: 1.4rem;
    }
}

@media (max-width: 400px) {
    .modal-content {
        padding: 18px;
        border-radius: 14px;
    }
    
    .modal-title {
        font-size: 1.2rem;
    }
    
    .form-group input,
    .form-group select {
        padding: 10px 12px;
        font-size: 0.9rem;
    }
    
    .form-group label {
        font-size: 0.85rem;
    }
    
    .close-btn {
        font-size: 1.3rem;
    }
}

        /* Stats cards */
        .stats-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 25px;
            margin-bottom: 35px;
        }

        .stat-card {
            background-color: white;
            border-radius: var(--border-radius);
            padding: 25px;
            box-shadow: var(--box-shadow);
            border: 1px solid rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
            text-align: center;
            border: 3px solid var(--primary); 
        }
        

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }

        .stat-card h3 {
            font-size: 0.95rem;
            color: #64748b;
            margin-bottom: 12px;
            font-weight: 500;
        }

        .stat-card p {
            font-size: 1.8rem;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 10px;
        }

        .stat-card .trend {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 12px;
            font-size: 0.9rem;
        }
        .trend {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-top: 12px;
    font-size: 0.9rem;
    color: var(--primary);
    opacity: 0.7;
}

.trend i {
    margin-right: 5px;
}
        /* Hamburger menu */
        .hamburger-menu {
            display: none;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: var(--primary);
            cursor: pointer;
            margin-right: 15px;
        }

        /* Header title container */
        .header-title-container {
            display: flex;
            align-items: center;
        }

       /* Improved Loading Overlay Styles */
.loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(255, 255, 255, 0.9);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2000;
    opacity: 0;
    visibility: hidden;
    transition: all 0.3s ease;
    backdrop-filter: blur(3px);
}

.loading-overlay.active {
    opacity: 1;
    visibility: visible;
}

.loading-card {
    background-color: white;
    border-radius: var(--border-radius);
    padding: 30px;
    box-shadow: var(--box-shadow);
    width: 220px;
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
}

.loading-text {
    font-size: 1rem;
    color: var(--primary);
    margin-bottom: 15px;
    font-weight: 500;
}

.loading-progress {
    height: 4px;
    width: 100%;
    background-color: rgba(52, 152, 219, 0.1);
    border-radius: 2px;
    overflow: hidden;
}

.loading-progress::after {
    content: '';
    display: block;
    height: 100%;
    width: 0;
    background-color: var(--secondary);
    border-radius: 2px;
    animation: progress 2s ease-in-out infinite;
}

@keyframes progress {
    0% { width: 0; }
    50% { width: 100%; }
    100% { width: 0; margin-left: 100%; }
}

        /* Success notification */
        .success-notification {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background-color: var(--success);
            color: white;
            padding: 15px 25px;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            display: flex;
            align-items: center;
            gap: 10px;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .success-notification.show {
            transform: translateY(0);
            opacity: 1;
        }

        .checkmark {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: block;
            stroke-width: 3;
            stroke: white;
            stroke-miterlimit: 10;
            box-shadow: inset 0 0 0 var(--success);
            animation: fill .4s ease-in-out .4s forwards, scale .3s ease-in-out .9s both;
        }

        .checkmark__circle {
            stroke-dasharray: 166;
            stroke-dashoffset: 166;
            stroke-width: 3;
            stroke-miterlimit: 10;
            stroke: white;
            fill: none;
            animation: stroke .6s cubic-bezier(0.65, 0, 0.45, 1) forwards;
        }

        .checkmark__check {
            transform-origin: 50% 50%;
            stroke-dasharray: 48;
            stroke-dashoffset: 48;
            animation: stroke .3s cubic-bezier(0.65, 0, 0.45, 1) .8s forwards;
        }

        @keyframes stroke {
            100% { stroke-dashoffset: 0; }
        }

        @keyframes scale {
            0%, 100% { transform: none; }
            50% { transform: scale3d(1.1, 1.1, 1); }
        }

        @keyframes fill {
            100% { box-shadow: inset 0 0 0 100px var(--success); }
        }

        /* Smooth scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 10px;
            transition: background 0.3s;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        /* Responsive adjustments */
        @media (max-width: 992px) {
            .products-grid {
                grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            }
        }

        @media (max-width: 768px) {
            .sidebar {
                width: 220px;
                padding: 20px 15px;
            }
            .main-content {
                margin-left: 220px;
            }
            .stats-container {
                grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            }
            .stat-card {
                text-align: left;
            }
            .stat-card .trend {
                justify-content: flex-start;
            }
        }

        @media (max-width: 576px) {
            .hamburger-menu {
                display: block;
            }
            
            .sidebar {
                transform: translateX(-100%);
                width: 280px;
                height: 100vh;
                position: fixed;
                top: 0;
                left: 0;
                z-index: 100;
            }
            
            .sidebar.show {
                transform: translateX(0);
            }

            .sidebar-close-btn {
                display: block;
            }
            
            .main-content {
                margin-left: 0;
            }
            
            .products-grid {
                grid-template-columns: 1fr;
            }
            
            .dashboard-header {
                flex-direction: row;
                align-items: center;
                gap: 15px;
            }
            
            .stats-container {
                grid-template-columns: 1fr 1fr;
            }
            
            header {
                padding: 15px 0;
                position: sticky;
                top: 0;
                z-index: 90;
            }
            
            .header-content {
                padding: 0 15px;
            }

            /* Responsive header title */
            h1 {
                font-size: 1.4rem;
                margin-left: 10px;
            }

            .header-title-container {
                display: flex;
                align-items: center;
            }

            .stat-card {
                text-align: center;
            }
            .stat-card .trend {
                justify-content: center;
            }
        }

        @media (max-width: 480px) {
            .stats-container {
                grid-template-columns: 1fr;
            }
            
            .modal-content {
                padding: 20px;
            }

            h1 {
                font-size: 1.2rem;
            }

            .dashboard-header {
                flex-direction: row;
                align-items: center;
            }

            .dashboard-header h2 {
                margin-right: 0;
                width: 100%;
                text-align: left;
            }
        }
        .floating-btn {
    display: none;
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background-color: var(--secondary);
    color: white;
    border: none;
    box-shadow: 0 2px 10px rgba(52, 152, 219, 0.3);
    cursor: pointer;
    align-items: center;
    justify-content: center;
    font-size: 1rem;
    z-index: 99;
    transition: all 0.3s ease;
    opacity: 0;
    transform: translateY(20px);
}

.floating-btn.visible {
    opacity: 1;
    transform: translateY(0);
}

@media (max-width: 576px) {
    .floating-btn {
        display: flex;
    }
}
.user-menu {
    position: relative;
    display: flex;
    align-items: center;
    gap: 15px;
}

.user-icon {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background-color: var(--secondary);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s;
    font-size: 1.2rem;
    border: 2px solid rgba(255, 255, 255, 0.2);
    overflow: hidden; /* Ensure the image stays within the circle */
}
.user-icon:hover {
    background-color: var(--dark);
    transform: scale(1.05);
    box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.3);
}

.dropdown-content {
    display: none;
    position: absolute;
    right: 0;
    background-color: white;
    width: 280px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
    border-radius: 12px;
    z-index: 100;
    overflow: hidden;
    top: 100%;
    margin-top: 15px;
    border: 1px solid rgba(0, 0, 0, 0.05);
}

.dropdown-content.show {
    display: block;
    animation: fadeIn 0.2s ease-out;
}

.user-info {
    display: flex;
    align-items: center;
    padding: 16px 20px;
    background: linear-gradient(135deg, var(--secondary), #4ecdc4);
    color: white;
    gap: 12px;
}

.user-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    overflow: hidden;
    flex-shrink: 0;
    border: 2px solid rgba(255, 255, 255, 0.3);
}

.user-avatar img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.user-text {
    display: flex;
    flex-direction: column;
    justify-content: center;
    min-width: 0; /* Prevents text overflow */
}

.user-name {
    font-weight: 600;
    font-size: 1rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.user-email {
    font-size: 0.85rem;
    opacity: 0.9;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
/* Circular loading animation for user icon */
.user-icon.loading::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    border-top-color: white;
    animation: spin 1s linear infinite;
    z-index: 1;
}

.user-icon.loading i {
    opacity: 0.3; /* Make the icon semi-transparent during loading */
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.dropdown-divider {
    height: 1px;
    background-color: rgba(0, 0, 0, 0.05);
    margin: 8px 0;
}

.dropdown-content a {
    color: var(--primary);
    padding: 12px 20px;
    text-decoration: none;
    display: flex;
    align-items: center;
    transition: all 0.2s;
    font-size: 0.95rem;
}

.dropdown-content a:hover {
    background-color: rgba(52, 152, 219, 0.08);
    color: var(--secondary);
    padding-left: 22px;
}

.dropdown-content i {
    margin-right: 12px;
    width: 18px;
    text-align: center;
    font-size: 0.9rem;
    color: var(--secondary);
}

@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}
#changeAvatarLink {
    display: block;
    color: var(--primary);
    padding: 12px 20px;
    text-decoration: none;
    transition: all 0.2s;
    font-size: 0.95rem;
}

#changeAvatarLink:hover {
    background-color: rgba(52, 152, 219, 0.08);
    color: var(--secondary);
    padding-left: 22px;
}

#changeAvatarLink i {
    margin-right: 12px;
    width: 18px;
    text-align: center;
    font-size: 0.9rem;
    color: var(--secondary);
}
/* Avatar Loading State */
.user-avatar.loading {
    position: relative;
}

.user-avatar.loading::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(255, 255, 255, 0.7);
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%234361ee'%3E%3Cpath d='M12,4V2A10,10 0 0,0 2,12H4A8,8 0 0,1 12,4Z'/%3E%3C/svg%3E");
    background-size: 24px;
    background-position: center;
    background-repeat: no-repeat;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}
@keyframes fadeIn {
        from { opacity: 0; transform: translateY(20px); }
        to { opacity: 1; transform: translateY(0); }
    }
    
    @keyframes fadeOut {
        from { opacity: 1; transform: translateY(0); }
        to { opacity: 0; transform: translateY(20px); }
    }
    
    .stock-notification {
        transition: all 0.3s ease;
    }
      /* Add this new style for the online indicator */
      .online-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            background-color: #0cd82e;
            border-radius: 50%;
            margin-left: 6px;
            position: relative;
            top: -1px;
        }

    </style>
</head>
<body>
    <button class="floating-btn" id="floatingBtn" onclick="scrollToTop()">
        <i class="fas fa-arrow-up"></i>
    </button>
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <h2>Vending Machine</h2>
            <button class="sidebar-close-btn" id="sidebarCloseBtn">&times;</button>
        </div>
        <ul class="sidebar-menu">
            <li><a href="#" class="active"><i class="fas fa-tachometer-alt"></i> Dashboard</a></li>
            <li><a href="#"><i class="fas fa-shopping-basket"></i> Products</a></li>
            <li><a href="#"><i class="fas fa-boxes"></i> Inventory</a></li>
            <li><a href="#"><i class="fas fa-chart-line"></i> Sales</a></li>
            <li><a href="#"><i class="fas fa-cog"></i> Settings</a></li>
        </ul>
        <div class="sidebar-footer">
            Developed by Vending Solutions Inc.
        </div>
    </div>

    <div class="main-content">
        <header>
            <div class="container header-content">
                <div class="header-title-container">
                    <button class="hamburger-menu" id="hamburgerMenu">
                        <span class="hamburger-icon"></span>
                    </button>
                    <h1>Dashboard</h1>
                </div>
                <div class="user-menu">
                    <div class="user-icon" id="userIcon">
                        <i class="fas fa-user-circle"></i>
                    </div>
                    
                    <div class="dropdown-content" id="dropdownContent">
                        <div class="user-info">
                            <div class="user-avatar" id="userAvatar">
                                <img src="https://ui-avatars.com/api/?name=User&background=3498db&color=fff&rounded=true" alt="User Avatar" id="avatarImage">
                            </div>
                            <div class="user-text">
                                <div class="user-name">
                                    <div class="online-indicator-container">
                                        Administrator
                                        <span class="online-indicator"></span>
                                    </div>
                                </div>
                                <div class="user-email" id="userEmailDisplay">user@example.com</div>
                            </div>
                        </div>
                        <div class="dropdown-divider"></div>
                        <input type="file" id="avatarUpload" accept="image/*" style="display: none;">
                        <a href="#" id="changeAvatarLink"><i class="fas fa-camera"></i> Change Profile Picture</a>
                        <a href="index.html" id="signOutLink"><i class="fas fa-sign-out-alt"></i> Sign Out</a>
                    </div>
                </div>
        </header>

        <div class="container">
            <div class="dashboard-header">
                <h2>Inventory Overview</h2>
                <button class="btn btn-primary" id="addProductBtn">
                    <i class="fas fa-plus"></i> Add Product
                </button>
            </div>

            <div class="stats-container" id="statsContainer">
                <!-- Stats will be dynamically inserted here -->
            </div>

            <div class="search-bar">
                <input type="text" placeholder="Search products..." id="searchInput">
                <button><i class="fas fa-search"></i></button>
            </div>

            <div class="products-grid" id="productsContainer">
                <!-- Products will be dynamically inserted here -->
            </div>
        </div>

        <!-- Edit Product Modal -->
        <div class="modal" id="editModal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 class="modal-title">Edit Product</h2>
                    <button class="close-btn" onclick="UIController.closeEditModal()">&times;</button>
                </div>
                <form id="editForm">
                    <input type="hidden" id="editProductId">
                    <div class="form-group">
                        <label for="editProductName">Product Name</label>
                        <input type="text" id="editProductName" required>
                    </div>
                    <div class="form-group">
                        <label for="editProductQuantity">Quantity</label>
                        <input type="number" id="editProductQuantity" min="0" required>
                    </div>
                    <div class="form-group">
                        <label for="editProductPrice">Price ($)</label>
                        <input type="number" step="0.01" id="editProductPrice" min="0" required>
                    </div>
                    <div class="modal-actions">
                        <button type="button" class="btn btn-cancel" onclick="UIController.closeEditModal()">Cancel</button>
                        <button type="submit" class="btn btn-save">Save Changes</button>
                    </div>
                </form>
            </div>
        </div>
        
        <!-- Add Product Modal -->
        <div class="modal" id="addModal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 class="modal-title">Add New Product</h2>
                    <button class="close-btn" onclick="UIController.closeAddModal()">&times;</button>
                </div>
                <form id="addForm">
                    <div class="form-group">
                        <label for="addProductName">Product Name</label>
                        <input type="text" id="addProductName" required>
                    </div>
                    <div class="form-group">
                        <label for="addProductQuantity">Quantity</label>
                        <input type="number" id="addProductQuantity" min="0" required>
                    </div>
                    <div class="form-group">
                        <label for="addProductPrice">Price ($)</label>
                        <input type="number" step="0.01" id="addProductPrice" min="0" required>
                    </div>
                    <div class="modal-actions">
                        <button type="button" class="btn btn-cancel" onclick="UIController.closeAddModal()">Cancel</button>
                        <button type="submit" class="btn btn-save">Add Product</button>
                    </div>
                </form>
            </div>
        </div>

        <!-- Delete Confirmation Modal -->
        <div class="modal" id="deleteModal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 class="modal-title">Confirm Delete</h2>
                    <button class="close-btn" onclick="UIController.closeDeleteModal()">&times;</button>
                </div>
                <div class="form-group">
                    <p>Are you sure you want to delete this product? This action cannot be undone.</p>
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn btn-cancel" onclick="UIController.closeDeleteModal()">Cancel</button>
                    <button type="button" class="btn btn-delete" id="confirmDeleteBtn">Delete</button>
                </div>
            </div>
        </div>

       <!-- Improved Loading Overlay -->
<div class="loading-overlay" id="loadingOverlay">
    <div class="loading-card">
        <div class="loading-text" id="loadingText">Loading...</div>
        <div class="loading-progress" id="loadingProgress"></div>
    </div>
</div>

        <!-- Success Notification -->
        <div class="success-notification" id="successNotification">
            <svg class="checkmark" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52">
                <circle class="checkmark__circle" cx="26" cy="26" r="25" fill="none"/>
                <path class="checkmark__check" fill="none" d="M14.1 27.2l7.1 7.2 16.7-16.8"/>
            </svg>
            <span>Changes saved successfully!</span>
        </div>
    </div>
    <script>
      // Check authentication status before loading the page
document.addEventListener('DOMContentLoaded', function() {
    // Check if user is authenticated (using localStorage in this example)
    const isAuthenticated = localStorage.getItem('isAuthenticated') === 'true';
    
    if (!isAuthenticated) {
        // Redirect to login page if not authenticated
        window.location.href = 'index.html';
        return;
    }
    
    // If authenticated, proceed with loading the page
    document.body.style.visibility = 'visible';
    
    // Initialize the app
    AppController.init();
});

// Configuration for jsonbin.io
const JsonBinConfig = {
    BIN_ID: localStorage.getItem('vendingMachineBinId') || '68099a148960c979a58bd4c7',
    API_KEY: '$2a$10$9frm67uZzvDcqqTrnu3t0ex8eM6piNOxzqSObryx/uOCoAGxvLQ4q',
    BASE_URL: 'https://api.jsonbin.io/v3/b',
    HEADERS: {
        'Content-Type': 'application/json',
        'X-Master-Key': '$2a$10$9frm67uZzvDcqqTrnu3t0ex8eM6piNOxzqSObryx/uOCoAGxvLQ4q',
        'X-Bin-Versioning': 'false'
    }
};
const ProfileBinConfig = {
    BIN_ID: '6809a77c8a456b7966901b35', // Fixed bin ID for all devices
    API_KEY: '$2a$10$9frm67uZzvDcqqTrnu3t0ex8eM6piNOxzqSObryx/uOCoAGxvLQ4q',
    BASE_URL: 'https://api.jsonbin.io/v3/b',
    HEADERS: {
        'Content-Type': 'application/json',
        'X-Master-Key': '$2a$10$9frm67uZzvDcqqTrnu3t0ex8eM6piNOxzqSObryx/uOCoAGxvLQ4q',
        'X-Bin-Versioning': 'false'
    }
};
// Database Service - Handles all CRUD operations with jsonbin.io
const DatabaseService = {
    products: [],
    isOnline: navigator.onLine,
    syncInterval: null,
    retryCount: 0,
    maxRetries: 3,
    syncInProgress: false,
    pendingUpdates: [],
    
    // Initialize the database
    initDatabase: function() {
        return new Promise((resolve, reject) => {
            // Show loading only if we don't have cached data
            if (!localStorage.getItem('vendingMachineData')) {
                this.showLoading();
            }
            
            // Try to use cached data first for immediate UI display
            const cachedData = localStorage.getItem('vendingMachineData');
            if (cachedData) {
                try {
                    const parsedData = JSON.parse(cachedData);
                    this.products = parsedData.products || [];
                    resolve(this.products);
                    
                    // Still fetch fresh data in background
                    this.fetchProducts().catch(error => {
                        console.log('Background sync failed, using cached data', error);
                    });
                    return;
                } catch (e) {
                    console.error('Error parsing cached data', e);
                    localStorage.removeItem('vendingMachineData');
                }
            }
            
            // No cached data available, fetch fresh
            if (JsonBinConfig.BIN_ID) {
                console.log('Using existing bin:', JsonBinConfig.BIN_ID);
                this.fetchProducts().then(resolve).catch(reject);
            } else {
                this.createNewBin().then(binId => {
                    JsonBinConfig.BIN_ID = binId;
                    localStorage.setItem('vendingMachineBinId', binId);
                    console.log('Created new bin:', binId);
                    this.fetchProducts().then(resolve).catch(reject);
                }).catch(reject);
            }
        });
    },
     // Add this new method for predictive analysis
     getStockNotifications: function() {
        return new Promise((resolve) => {
            const notifications = [];
            const now = new Date();
            const currentHour = now.getHours();
            
            // Analyze each product for stock status
            this.products.forEach(product => {
                // Calculate average daily sales (simplified example)
                const avgDailySales = 2; // This would normally be calculated from historical data
                
                // Check stock status
                if (product.quantity === 0) {
                    notifications.push({
                        productId: product.id,
                        productName: product.name,
                        message: `${product.name} is out of stock!`,
                        severity: 'high',
                        type: 'out-of-stock'
                    });
                } else if (product.quantity < 5) {
                    // Predict when it will run out based on average sales
                    const daysRemaining = Math.floor(product.quantity / avgDailySales);
                    
                    notifications.push({
                        productId: product.id,
                        productName: product.name,
                        message: `${product.name} is low in stock (${product.quantity} left). ` +
                                  `Estimated to run out in ${daysRemaining} day(s).`,
                        severity: 'medium',
                        type: 'low-stock'
                    });
                } else if (product.quantity < 10 && currentHour >= 14) {
                    // Suggest restocking in the afternoon if below threshold
                    notifications.push({
                        productId: product.id,
                        productName: product.name,
                        message: `Consider restocking ${product.name} before tomorrow.`,
                        severity: 'low',
                        type: 'restock-suggestion'
                    });
                }
            });
            
            resolve(notifications);
        });
    },
    // Create a new bin with default products
    createNewBin: function() {
        return new Promise((resolve, reject) => {
            const defaultProducts = [
                { id: 1, name: "Mineral Water", quantity: 15, price: 1.50, lastUpdated: Date.now() },
                { id: 2, name: "Orange Juice", quantity: 8, price: 2.00, lastUpdated: Date.now() },
                { id: 3, name: "Energy Drink", quantity: 12, price: 2.50, lastUpdated: Date.now() },
                { id: 4, name: "Iced Tea", quantity: 5, price: 1.75, lastUpdated: Date.now() }
            ];
            
            const payload = {
                products: defaultProducts,
                metadata: {
                    description: "VendingMachineDB",
                    created: new Date().toISOString()
                }
            };
            
            fetch(JsonBinConfig.BASE_URL, {
                method: 'POST',
                headers: JsonBinConfig.HEADERS,
                body: JSON.stringify(payload)
            })
            .then(response => response.json())
            .then(data => {
                if (data.metadata && data.metadata.id) {
                    // Cache the data immediately
                    localStorage.setItem('vendingMachineData', JSON.stringify(payload));
                    resolve(data.metadata.id);
                } else {
                    reject(new Error('Failed to create bin'));
                }
            })
            .catch(reject);
        });
    },
    
    // Fetch all products from the bin
    fetchProducts: function() {
        return new Promise((resolve, reject) => {
            if (!JsonBinConfig.BIN_ID) {
                reject(new Error('Bin ID not set'));
                return;
            }
            
            fetch(`${JsonBinConfig.BASE_URL}/${JsonBinConfig.BIN_ID}/latest`, {
                method: 'GET',
                headers: JsonBinConfig.HEADERS
            })
            .then(response => response.json())
            .then(data => {
                if (data.record && data.record.products) {
                    this.products = data.record.products;
                    // Cache the data
                    localStorage.setItem('vendingMachineData', JSON.stringify(data.record));
                    resolve(this.products);
                    this.startSyncInterval();
                } else {
                    reject(new Error('Invalid data format from bin'));
                }
            })
            .catch(error => {
                console.error('Error fetching products:', error);
                reject(error);
            });
        });
    },
    
    // Update the entire bin (full sync)
    updateBin: function() {
        return new Promise((resolve, reject) => {
            if (this.syncInProgress) {
                console.log('Sync already in progress, queuing update');
                return resolve(false);
            }
            
            if (!JsonBinConfig.BIN_ID) {
                reject(new Error('Bin ID not set'));
                return;
            }
            
            this.syncInProgress = true;
            
            const payload = {
                products: this.products,
                metadata: {
                    description: "VendingMachineDB",
                    lastUpdated: new Date().toISOString()
                }
            };
            
            fetch(`${JsonBinConfig.BASE_URL}/${JsonBinConfig.BIN_ID}`, {
                method: 'PUT',
                headers: JsonBinConfig.HEADERS,
                body: JSON.stringify(payload)
            })
            .then(response => response.json())
            .then(data => {
                this.syncInProgress = false;
                this.retryCount = 0;
                
                if (data.record) {
                    localStorage.setItem('vendingMachineData', JSON.stringify(data.record));
                    resolve(data.record.products);
                    
                    // Process any pending updates
                    if (this.pendingUpdates.length > 0) {
                        console.log('Processing', this.pendingUpdates.length, 'pending updates');
                        const updates = [...this.pendingUpdates];
                        this.pendingUpdates = [];
                        updates.forEach(update => this.processUpdate(update));
                    }
                } else {
                    reject(new Error('Failed to update bin'));
                }
            })
            .catch(error => {
                this.syncInProgress = false;
                console.error('Error updating bin:', error);
                this.retryCount++;
                
                if (this.retryCount <= this.maxRetries) {
                    console.log(`Retrying update (attempt ${this.retryCount})`);
                    setTimeout(() => this.updateBin().then(resolve).catch(reject), 1000 * this.retryCount);
                } else {
                    reject(error);
                }
            });
        });
    },
    
    // Process pending updates
    processUpdate: function(update) {
        const { action, data, resolve, reject } = update;
        
        switch (action) {
            case 'add':
                this.addProductLocal(data.product)
                    .then(resolve)
                    .catch(reject);
                break;
            case 'update':
                this.updateProductLocal(data.id, data.updates)
                    .then(resolve)
                    .catch(reject);
                break;
            case 'delete':
                this.deleteProductLocal(data.id)
                    .then(resolve)
                    .catch(reject);
                break;
        }
    },
    
    // Add product locally
    addProductLocal: function(product) {
        return new Promise((resolve) => {
            const newId = this.products.length > 0 ? 
                Math.max(...this.products.map(p => p.id)) + 1 : 1;
            
            const newProduct = {
                ...product,
                id: newId,
                lastUpdated: Date.now()
            };
            
            this.products.push(newProduct);
            localStorage.setItem('vendingMachineData', JSON.stringify({ products: this.products }));
            resolve(newProduct);
        });
    },
    
    // Update product locally
    updateProductLocal: function(id, updates) {
        return new Promise((resolve, reject) => {
            const index = this.products.findIndex(p => p.id === id);
            
            if (index === -1) {
                reject(new Error('Product not found'));
                return;
            }
            
            this.products[index] = {
                ...this.products[index],
                ...updates,
                lastUpdated: Date.now()
            };
            
            localStorage.setItem('vendingMachineData', JSON.stringify({ products: this.products }));
            resolve(this.products[index]);
        });
    },
    
    // Delete product locally
    deleteProductLocal: function(id) {
        return new Promise((resolve, reject) => {
            const index = this.products.findIndex(p => p.id === id);
            
            if (index === -1) {
                reject(new Error('Product not found'));
                return;
            }
            
            this.products.splice(index, 1);
            localStorage.setItem('vendingMachineData', JSON.stringify({ products: this.products }));
            resolve(true);
        });
    },
    
    // Setup network connectivity listeners
    setupNetworkListeners: function() {
        window.addEventListener('online', () => {
            this.isOnline = true;
            console.log('Network connection restored - syncing changes');
            this.fetchProducts().then(() => {
                UIController.refreshData();
            });
        });
        
        window.addEventListener('offline', () => {
            this.isOnline = false;
            console.log('Network connection lost - changes will be queued');
        });
    },
    
    // In DatabaseService, modify the startSyncInterval method:
startSyncInterval: function() {
    if (this.syncInterval) clearInterval(this.syncInterval);
    this.syncInterval = setInterval(() => {
        if (this.isOnline) {
            // Don't show loading screen for background syncs
            this.fetchProducts().then(() => {
                UIController.refreshData(false); // Pass false to indicate background sync
            }).catch(error => {
                console.error('Background sync error:', error);
            });
        }
    }, 3000); // Sync every 30 seconds when online
},
    
    // Get all products
    getAllProducts: function() {
        return Promise.resolve(this.products);
    },
    
    // Get a single product by ID
    getProductById: function(id) {
        return new Promise((resolve, reject) => {
            const product = this.products.find(p => p.id === id);
            if (product) {
                resolve(product);
            } else {
                reject(new Error('Product not found'));
            }
        });
    },
    
    // Add a new product
    addProduct: function(product) {
        return new Promise((resolve, reject) => {
            const update = {
                action: 'add',
                data: { product },
                resolve,
                reject
            };
            
            if (this.syncInProgress || !this.isOnline) {
                this.pendingUpdates.push(update);
                this.addProductLocal(product).then(resolve).catch(reject);
            } else {
                this.addProductLocal(product)
                    .then(newProduct => {
                        this.updateBin()
                            .then(() => resolve(newProduct))
                            .catch(error => {
                                this.pendingUpdates.push(update);
                                reject(error);
                            });
                    })
                    .catch(reject);
            }
        });
    },
    
    updateProduct: function(id, updates) {
    return new Promise((resolve, reject) => {
        const update = {
            action: 'update',
            data: { id, updates },
            resolve,
            reject
        };
        
        if (this.syncInProgress || !this.isOnline) {
            this.pendingUpdates.push(update);
            this.updateProductLocal(id, updates).then(resolve).catch(reject);
        } else {
            this.updateProductLocal(id, updates)
                .then(updatedProduct => {
                    this.updateBin()
                        .then(() => resolve(updatedProduct))
                        .catch(error => {
                            this.pendingUpdates.push(update);
                            reject(error);
                        });
                })
                .catch(reject);
        }
    });
},
    
    // Delete a product
    deleteProduct: function(id) {
        return new Promise((resolve, reject) => {
            const update = {
                action: 'delete',
                data: { id },
                resolve,
                reject
            };
            
            if (this.syncInProgress || !this.isOnline) {
                this.pendingUpdates.push(update);
                this.deleteProductLocal(id).then(resolve).catch(reject);
            } else {
                this.deleteProductLocal(id)
                    .then(success => {
                        this.updateBin()
                            .then(() => resolve(success))
                            .catch(error => {
                                this.pendingUpdates.push(update);
                                reject(error);
                            });
                    })
                    .catch(reject);
            }
        });
    },
    
   // Get statistics for the dashboard
getStats: function() {
    return new Promise((resolve) => {
        const totalProducts = this.products.length;
        const lowStockItems = this.products.filter(p => p.quantity > 0 && p.quantity < 5).length;
        const outOfStock = this.products.filter(p => p.quantity === 0).length;
        const totalValue = this.products.reduce((sum, product) => sum + (product.price * product.quantity), 0);
        
        resolve({
            totalProducts,
            lowStockItems,
            outOfStock,
            totalValue
        });
    });
},
    
    // Show loading overlay
    showLoading: function() {
        const loadingOverlay = document.getElementById('loadingOverlay');
        if (loadingOverlay) {
            loadingOverlay.style.display = 'flex';
            setTimeout(() => {
                loadingOverlay.classList.add('active');
            }, 10);
        }
    },
    
    // Hide loading overlay
    hideLoading: function() {
        const loadingOverlay = document.getElementById('loadingOverlay');
        if (loadingOverlay) {
            loadingOverlay.classList.remove('active');
            setTimeout(() => {
                loadingOverlay.style.display = 'none';
            }, 300);
        }
    }
};
const LoadingController = {
    show: function(message = "Loading...") {
        const overlay = document.getElementById('loadingOverlay');
        const text = document.getElementById('loadingText');
        
        if (text) text.textContent = message;
        if (overlay) {
            overlay.style.display = 'flex';
            setTimeout(() => {
                overlay.classList.add('active');
            }, 10);
        }
    },
    
    hide: function() {
        const overlay = document.getElementById('loadingOverlay');
        if (overlay) {
            overlay.classList.remove('active');
            setTimeout(() => {
                overlay.style.display = 'none';
            }, 300);
        }
    },
    
    updateProgress: function(percent) {
        const progress = document.getElementById('loadingProgress');
        if (progress) {
            progress.style.width = `${percent}%`;
        }
    },
    
    setMessage: function(message) {
        const text = document.getElementById('loadingText');
        if (text) text.textContent = message;
    }
};

const UserProfileService = {
    // Save user avatar to the profile bin
    saveUserAvatar: function(email, avatarData) {
        return new Promise((resolve, reject) => {
            // Use the fixed bin ID directly
            const binId = ProfileBinConfig.BIN_ID;
            
            // First get the current profile bin data
            fetch(`${ProfileBinConfig.BASE_URL}/${binId}/latest`, {
                method: 'GET',
                headers: ProfileBinConfig.HEADERS
            })
            .then(response => {
                if (!response.ok) {
                    if (response.status === 404) {
                        return { record: {} };
                    }
                    throw new Error('Failed to fetch profile data');
                }
                return response.json();
            })
            .then(data => {
                const currentData = data.record || {};
                
                // Create updated data with new avatar
                const updatedData = {
                    ...currentData,
                    [email]: {
                        avatar: avatarData,
                        lastUpdated: new Date().toISOString()
                    }
                };

                // Save the updated data to the profile bin
                return fetch(`${ProfileBinConfig.BASE_URL}/${binId}`, {
                    method: 'PUT',
                    headers: ProfileBinConfig.HEADERS,
                    body: JSON.stringify(updatedData)
                });
            })
            .then(response => response.json())
            .then(data => {
                if (data.record) {
                    // Update local storage
                    const profileData = JSON.parse(localStorage.getItem('profileData') || '{}');
                    profileData[email] = data.record[email];
                    localStorage.setItem('profileData', JSON.stringify(profileData));
                    resolve(data.record[email].avatar);
                } else {
                    reject(new Error('Invalid response format'));
                }
            })
            .catch(reject);
        });
    },
createNewProfileBin: function() {
    return new Promise((resolve, reject) => {
        fetch(ProfileBinConfig.BASE_URL, {
            method: 'POST',
            headers: ProfileBinConfig.HEADERS,
            body: JSON.stringify({
                profiles: {},
                metadata: {
                    description: "User Profile Pictures Database",
                    created: new Date().toISOString()
                }
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.metadata && data.metadata.id) {
                ProfileBinConfig.BIN_ID = data.metadata.id;
                localStorage.setItem('profileBinId', data.metadata.id);
                resolve(data.metadata.id);
            } else {
                reject(new Error('Failed to create profile bin'));
            }
        })
        .catch(reject);
    });
},

saveUserAvatar: function(email, avatarData) {
        return new Promise((resolve, reject) => {
            // Use the fixed bin ID directly
            const binId = ProfileBinConfig.BIN_ID;
            
            // First get the current profile bin data
            fetch(`${ProfileBinConfig.BASE_URL}/${binId}/latest`, {
                method: 'GET',
                headers: ProfileBinConfig.HEADERS
            })
            .then(response => {
                if (!response.ok) {
                    // If bin doesn't exist, create an empty record
                    if (response.status === 404) {
                        return { record: {} };
                    }
                    throw new Error('Failed to fetch profile data');
                }
                return response.json();
            })
            .then(data => {
                const currentData = data.record || {};
                
                // Create updated data with new avatar
                const updatedData = {
                    ...currentData,
                    [email]: {
                        avatar: avatarData,
                        lastUpdated: new Date().toISOString()
                    }
                };

                // Save the updated data to the profile bin
                return fetch(`${ProfileBinConfig.BASE_URL}/${binId}`, {
                    method: 'PUT',
                    headers: ProfileBinConfig.HEADERS,
                    body: JSON.stringify(updatedData)
                });
            })
            .then(response => response.json())
            .then(data => {
                if (data.record) {
                    // Update local storage
                    const profileData = JSON.parse(localStorage.getItem('profileData') || '{}');
                    profileData[email] = data.record[email];
                    localStorage.setItem('profileData', JSON.stringify(profileData));
                    resolve(data.record[email].avatar);
                } else {
                    reject(new Error('Invalid response format'));
                }
            })
            .catch(reject);
        });
    },
    // In UserProfileService, modify the getUserAvatar method:
  // Get user avatar from the profile bin
  getUserAvatar: function(email) {
        return new Promise((resolve) => {
            // First check local storage (synchronous for immediate response)
            const profileData = JSON.parse(localStorage.getItem('profileData') || '{}');
            if (profileData[email] && profileData[email].avatar) {
                resolve(profileData[email].avatar);
                
                // Then check for updates in background
                setTimeout(() => {
                    fetch(`${ProfileBinConfig.BASE_URL}/${ProfileBinConfig.BIN_ID}/latest`, {
                        method: 'GET',
                        headers: ProfileBinConfig.HEADERS
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.record && data.record[email] && 
                            data.record[email].avatar !== profileData[email].avatar) {
                            // Update local storage if newer version exists
                            localStorage.setItem('profileData', JSON.stringify(data.record));
                            // Update UI if different
                            if (UIController.elements.userEmailDisplay.textContent === email) {
                                UIController.updateAvatarUI(data.record[email].avatar);
                            }
                        }
                    })
                    .catch(console.error);
                }, 0);
                return;
            }
            
            // If not in local storage, try remote
            fetch(`${ProfileBinConfig.BASE_URL}/${ProfileBinConfig.BIN_ID}/latest`, {
                method: 'GET',
                headers: ProfileBinConfig.HEADERS
            })
            .then(response => response.json())
            .then(data => {
                if (data.record && data.record[email]) {
                    // Cache the data
                    localStorage.setItem('profileData', JSON.stringify(data.record));
                    resolve(data.record[email].avatar);
                } else {
                    resolve(null); // No avatar found
                }
            })
            .catch(error => {
                console.error('Error fetching user profile:', error);
                resolve(null); // Resolve with null instead of rejecting
            });
        });
    }
};
// UI Controller - Handles all DOM manipulation and user interactions
const UIController = {
    elements: {
        productsContainer: document.getElementById('productsContainer'),
        statsContainer: document.getElementById('statsContainer'),
        searchInput: document.getElementById('searchInput'),
        editModal: document.getElementById('editModal'),
        addModal: document.getElementById('addModal'),
        deleteModal: document.getElementById('deleteModal'),
        editForm: document.getElementById('editForm'),
        addForm: document.getElementById('addForm'),
        editProductId: document.getElementById('editProductId'),
        editProductName: document.getElementById('editProductName'),
        editProductQuantity: document.getElementById('editProductQuantity'),
        editProductPrice: document.getElementById('editProductPrice'),
        addProductName: document.getElementById('addProductName'),
        addProductQuantity: document.getElementById('addProductQuantity'),
        addProductPrice: document.getElementById('addProductPrice'),
        confirmDeleteBtn: document.getElementById('confirmDeleteBtn'),
        hamburgerMenu: document.getElementById('hamburgerMenu'),
        sidebar: document.getElementById('sidebar'),
        sidebarCloseBtn: document.getElementById('sidebarCloseBtn'),
        userIcon: document.getElementById('userIcon'),
        dropdownContent: document.getElementById('dropdownContent'),
        loadingOverlay: document.getElementById('loadingOverlay'),
        successNotification: document.getElementById('successNotification'),
        floatingBtn: document.getElementById('floatingBtn'),
        signOutLink: document.getElementById('signOutLink'),
        addProductBtn: document.getElementById('addProductBtn'),
        avatarUpload: document.getElementById('avatarUpload'),
        changeAvatarLink: document.getElementById('changeAvatarLink'),
        userEmailDisplay: document.getElementById('userEmailDisplay')
    },

    state: {
        productToDelete: null,
        currentProducts: [],
        currentStats: null,
        isOnline: navigator.onLine
    },

    // Initialize the UI
    init: function() {
        this.setupEventListeners();
        this.setupScrollListener();
        this.setupNetworkStatus();
        
        // Immediately render cached data if available
        const cachedData = localStorage.getItem('vendingMachineData');
        if (cachedData) {
            try {
                const parsedData = JSON.parse(cachedData);
                this.state.currentProducts = parsedData.products || [];
                this.renderProducts(this.state.currentProducts);
                this.renderStats({
                    totalProducts: this.state.currentProducts.length,
                    lowStockItems: this.state.currentProducts.filter(p => p.quantity > 0 && p.quantity < 5).length,
                    outOfStock: this.state.currentProducts.filter(p => p.quantity === 0).length,
                    totalValue: this.state.currentProducts.reduce((sum, product) => sum + (product.price * product.quantity), 0)
                });
            } catch (e) {
                console.error('Error parsing cached data', e);
            }
        }
        
        // Then initialize the database and load fresh data
        DatabaseService.initDatabase().then(() => {
            this.refreshData();
        }).catch(error => {
            console.error('Database initialization failed:', error);
            this.showError('Failed to initialize database. Please check your connection.');
        });
        
        // Load user info and avatar
        this.loadUserInfo();
    },
    // Add this new method to show notifications
    showStockNotifications: function() {
        DatabaseService.getStockNotifications().then(notifications => {
            if (notifications.length > 0) {
                // Create notification container if it doesn't exist
                let notificationContainer = document.getElementById('stockNotifications');
                
                if (!notificationContainer) {
                    notificationContainer = document.createElement('div');
                    notificationContainer.id = 'stockNotifications';
                    notificationContainer.style.position = 'fixed';
                    notificationContainer.style.top = '70px';
                    notificationContainer.style.right = '20px';
                    notificationContainer.style.zIndex = '1000';
                    notificationContainer.style.maxWidth = '350px';
                    document.body.appendChild(notificationContainer);
                }
                
                // Clear existing notifications
                notificationContainer.innerHTML = '';
                
                // Add each notification
                notifications.forEach(notification => {
                    const notificationElement = document.createElement('div');
                    notificationElement.className = 'stock-notification';
                    notificationElement.style.padding = '15px';
                    notificationElement.style.marginBottom = '10px';
                    notificationElement.style.borderRadius = 'var(--border-radius)';
                    notificationElement.style.boxShadow = 'var(--box-shadow)';
                    notificationElement.style.backgroundColor = 'white';
                    notificationElement.style.borderLeft = `4px solid ${
                        notification.severity === 'high' ? 'var(--danger)' : 
                        notification.severity === 'medium' ? 'var(--warning)' : 'var(--secondary)'
                    }`;
                    notificationElement.style.animation = 'fadeIn 0.3s ease-out';
                    
                    notificationElement.innerHTML = `
                        <div style="font-weight: 600; margin-bottom: 5px;">
                            ${notification.productName}
                        </div>
                        <div>${notification.message}</div>
                    `;
                    
                    notificationContainer.appendChild(notificationElement);
                });
                
                // Auto-hide after 10 seconds
                setTimeout(() => {
                    notificationContainer.style.animation = 'fadeOut 0.3s ease-out';
                    setTimeout(() => {
                        notificationContainer.remove();
                    }, 300);
                }, 10000);
            }
        });
    },
   // In UIController
   loadUserInfo: function() {
    const savedCredentials = JSON.parse(localStorage.getItem('userCredentials'));
    if (savedCredentials && savedCredentials.email) {
        // Update email display
        if (this.elements.userEmailDisplay) {
            this.elements.userEmailDisplay.textContent = savedCredentials.email;
        }
        
        // Load avatar from profile bin
        UserProfileService.getUserAvatar(savedCredentials.email)
            .then(avatarData => {
                if (avatarData) {
                    this.updateAvatarUI(avatarData);
                }
            })
            .catch(error => {
                console.error('Error loading avatar:', error);
            });
    }
},
updateAvatarUI: function(avatarData) {
    const userAvatar = document.getElementById('avatarImage');
    const userIcon = document.getElementById('userIcon');
    
    // Update both the dropdown avatar and the user icon
    if (avatarData) {
        // For the dropdown avatar
        if (userAvatar) {
            userAvatar.src = avatarData;
        }
        
        // For the user icon in the header
        if (userIcon) {
            userIcon.innerHTML = '';
            const img = document.createElement('img');
            img.src = avatarData;
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.borderRadius = '50%';
            img.style.objectFit = 'cover';
            userIcon.appendChild(img);
        }
    } else {
        // Fallback to default icon if no avatar
        if (userAvatar) {
            userAvatar.src = 'https://ui-avatars.com/api/?name=User&background=3498db&color=fff&rounded=true';
        }
        if (userIcon) {
            userIcon.innerHTML = '<i class="fas fa-user-circle"></i>';
        }
    }
},
        
// In UIController, modify the handleAvatarUpload method:
handleAvatarUpload: function(e) {
    if (!e.target.files || !e.target.files[0]) return;

    const file = e.target.files[0];
    const validExtensions = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
    
    if (!validExtensions.includes(file.type)) {
        this.showSuccessNotification('Please upload a valid image (JPEG, PNG, GIF, or WebP)');
        e.target.value = '';
        return;
    }

    if (file.size > 2 * 1024 * 1024) {
        this.showSuccessNotification('Image too large (max 2MB)');
        e.target.value = '';
        return;
    }

    const userIcon = document.getElementById('userIcon');
    if (userIcon) {
        userIcon.classList.add('loading');
    }

    const reader = new FileReader();
    
    reader.onload = async (event) => {
        const savedCredentials = JSON.parse(localStorage.getItem('userCredentials'));
        if (!savedCredentials || !savedCredentials.email) {
            this.showSuccessNotification('Session expired. Please sign in again.');
            e.target.value = '';
            this.updateAvatarUI(null);
            if (userIcon) userIcon.classList.remove('loading');
            return;
        }
        
        try {
            // Update UI immediately with the new image
            this.updateAvatarUI(event.target.result);
            
            // Save to profile bin
            await UserProfileService.saveUserAvatar(savedCredentials.email, event.target.result);
            this.showSuccessNotification('Profile picture updated!');
        } catch (error) {
            console.error('Upload error:', error);
            this.showSuccessNotification('Failed to save. Using local version.');
        } finally {
            if (userIcon) userIcon.classList.remove('loading');
            e.target.value = '';
        }
    };
    
    reader.onerror = () => {
        this.showSuccessNotification('Error reading image file');
        e.target.value = '';
        this.updateAvatarUI(null);
        if (userIcon) userIcon.classList.remove('loading');
    };
    
    reader.readAsDataURL(file);
},

// Optimize the save with retry method
saveAvatarWithRetry: async function(email, avatarData) {
    // First try to save to localStorage for immediate response
    const profileData = JSON.parse(localStorage.getItem('profileData') || '{}');
    profileData[email] = { avatar: avatarData, lastUpdated: new Date().toISOString() };
    localStorage.setItem('profileData', JSON.stringify(profileData));
    
    // Then attempt to sync with server in background
    let attempts = 0;
    const maxAttempts = 2; // Reduced from 3 to minimize delay
    
    while (attempts < maxAttempts) {
        try {
            await UserProfileService.saveUserAvatar(email, avatarData);
            return; // Success
        } catch (error) {
            console.error(`Attempt ${attempts + 1} failed:`, error);
            attempts++;
            if (attempts < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, 1000 * attempts));
            }
        }
    }
    
    // If all attempts fail, the local version will still be used
    console.log('Failed to sync with server, using local version');
},
// Image compression helper
compressImage: function(dataUrl) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.src = dataUrl;
        
        img.onload = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Set maximum dimensions
            const MAX_SIZE = 800;
            let width = img.width;
            let height = img.height;
            
            if (width > height) {
                if (width > MAX_SIZE) {
                    height *= MAX_SIZE / width;
                    width = MAX_SIZE;
                }
            } else {
                if (height > MAX_SIZE) {
                    width *= MAX_SIZE / height;
                    height = MAX_SIZE;
                }
            }
            
            canvas.width = width;
            canvas.height = height;
            
            try {
                ctx.drawImage(img, 0, 0, width, height);
                resolve(canvas.toDataURL('image/jpeg', 0.7));
            } catch (error) {
                reject(error);
            }
        };
        
        img.onerror = reject;
    });
},
    
    // Setup network status indicator
    setupNetworkStatus: function() {
        window.addEventListener('online', () => {
            this.state.isOnline = true;
            this.showNetworkStatus();
        });
        
        window.addEventListener('offline', () => {
            this.state.isOnline = false;
            this.showNetworkStatus();
        });
        
        this.showNetworkStatus();
    },
    
    // Show network status
    showNetworkStatus: function() {
        console.log(this.state.isOnline ? 'Online' : 'Offline');
    },
    
    // In UIController, modify the refreshData method:
refreshData: function(showLoading = true) {
    if (showLoading) {
        DatabaseService.showLoading();
    }
    
    Promise.all([
        DatabaseService.getAllProducts(),
        DatabaseService.getStats()
    ]).then(([products, stats]) => {
        this.state.currentProducts = products;
        this.state.currentStats = stats;
        this.renderProducts(products);
        this.renderStats(stats);
        if (showLoading) {
            DatabaseService.hideLoading();
        }
    }).catch(error => {
        console.error('Error refreshing data:', error);
        if (showLoading) {
            DatabaseService.hideLoading();
        }
    });
},

    // Render products to the DOM
    renderProducts: function(products) {
        if (!this.elements.productsContainer) return;
        
        this.elements.productsContainer.innerHTML = '';
        
        if (products.length === 0) {
            this.elements.productsContainer.innerHTML = '<p class="no-products">No products found</p>';
            return;
        }
        
        // Sort by last updated (newest first)
        products.sort((a, b) => b.lastUpdated - a.lastUpdated);
        
        products.forEach(product => {
            const statusClass = this.getStatusClass(product.quantity);
            
            const productCard = document.createElement('div');
            productCard.className = 'product-card';
            productCard.innerHTML = `
                <div class="product-info">
                    <div class="product-name">${product.name}</div>
                    <div class="product-meta">
                        <div class="product-quantity">
                            <span class="status-indicator ${statusClass}"></span>
                            ${product.quantity} in stock
                        </div>
                        <div class="product-price">$${product.price.toFixed(2)}</div>
                    </div>
                    <div class="product-actions">
                        <button class="btn btn-edit" data-id="${product.id}">
                            <i class="fas fa-edit"></i> Edit
                        </button>
                        <button class="btn btn-delete" data-id="${product.id}">
                            <i class="fas fa-trash"></i> Delete
                        </button>
                    </div>
                </div>
            `;
            
            this.elements.productsContainer.appendChild(productCard);
        });
    },

    // Render statistics to the dashboard
renderStats: function(stats) {
    if (!this.elements.statsContainer || !stats) return;
    
    this.elements.statsContainer.innerHTML = `
        <div class="stat-card">
            <h3>Total Products</h3>
            <p>${stats.totalProducts}</p>
            <div class="trend">
                <i class="fas fa-chart-line"></i> Updated just now
            </div>
        </div>
        <div class="stat-card">
            <h3>Low Stock Items</h3>
            <p>${stats.lowStockItems}</p>
            <div class="trend">
                <i class="fas fa-exclamation-triangle"></i> Needs attention
            </div>
        </div>
        <div class="stat-card">
            <h3>Out of Stock</h3>
            <p>${stats.outOfStock}</p>
            <div class="trend">
                <i class="fas fa-shopping-cart"></i> Restock needed
            </div>
        </div>
        <div class="stat-card">
            <h3>Total Value</h3>
            <p>$${stats.totalValue.toFixed(2)}</p>
            <div class="trend">
                <i class="fas fa-dollar-sign"></i> Current inventory value
            </div>
        </div>
    `;
},

    // Get status class based on quantity
    getStatusClass: function(quantity) {
        if (quantity === 0) return 'status-out';
        if (quantity < 5) return 'status-low';
        return 'status-available';
    },

   // In UIController's searchProducts method:
searchProducts: function() {
    DatabaseService.showLoading();
    
    setTimeout(() => {
        const searchTerm = this.elements.searchInput.value.toLowerCase();
        const filteredProducts = this.state.currentProducts.filter(product => 
            product.name.toLowerCase().includes(searchTerm)
        );
        this.renderProducts(filteredProducts);
        DatabaseService.hideLoading();
    }, 300);
},

    // Open edit modal
openEditModal: function(productId) {
    DatabaseService.getProductById(productId).then(product => {
        if (product) {
            this.elements.editProductId.value = product.id;
            this.elements.editProductName.value = product.name;
            this.elements.editProductQuantity.value = product.quantity;
            this.elements.editProductPrice.value = product.price;
            this.showModal(this.elements.editModal);
        }
    }).catch(error => {
        console.error('Error getting product:', error);
    });
},

    // Open add product modal
    openAddProductModal: function() {
        this.elements.addForm.reset();
        this.showModal(this.elements.addModal);
    },

    // Show delete confirmation modal
    showDeleteModal: function(productId) {
        this.state.productToDelete = productId;
        this.showModal(this.elements.deleteModal);
    },

    // Show modal with animation
    showModal: function(modal) {
        if (!modal) return;
        modal.style.display = 'flex';
        setTimeout(() => {
            modal.classList.add('show');
        }, 10);
    },

    // Close modal with animation
    closeModal: function(modal) {
        if (!modal) return;
        modal.classList.remove('show');
        setTimeout(() => {
            modal.style.display = 'none';
        }, 300);
    },

    // Close edit modal
    closeEditModal: function() {
        this.closeModal(this.elements.editModal);
    },

    // Close add modal
    closeAddModal: function() {
        this.closeModal(this.elements.addModal);
    },

    // Close delete modal
    closeDeleteModal: function() {
        this.closeModal(this.elements.deleteModal);
    },

    // Show success notification
    showSuccessNotification: function(message = 'Changes saved successfully!') {
        if (!this.elements.successNotification) return;
        
        const messageSpan = this.elements.successNotification.querySelector('span');
        if (messageSpan) {
            messageSpan.textContent = message;
        }
        
        this.elements.successNotification.classList.add('show');
        setTimeout(() => {
            this.elements.successNotification.classList.remove('show');
        }, 3000);
    },

    saveProduct: function(e) {
    e.preventDefault();
    DatabaseService.showLoading();
    
    const productData = {
        name: this.elements.editProductName.value,
        quantity: parseInt(this.elements.editProductQuantity.value),
        price: parseFloat(this.elements.editProductPrice.value)
    };
    
    const productId = parseInt(this.elements.editProductId.value);
    
    DatabaseService.updateProduct(productId, productData)
        .then(() => {
            this.refreshData(); // This will update the UI with the new data
            this.closeEditModal();
            this.showSuccessNotification();
        })
        .catch(error => {
            console.error('Error updating product:', error);
            DatabaseService.hideLoading();
            this.showSuccessNotification('Failed to update product. Please try again.');
        });
},
addProduct: function(e) {
    e.preventDefault();
    DatabaseService.showLoading();
    
    const productData = {
        name: this.elements.addProductName.value,
        quantity: parseInt(this.elements.addProductQuantity.value),
        price: parseFloat(this.elements.addProductPrice.value)
    };
    
    DatabaseService.addProduct(productData)
        .then(() => {
            this.refreshData(true); // Show loading for user-initiated refresh
            this.closeAddModal();
            this.showSuccessNotification();
        })
        .catch(error => {
            console.error('Error adding product:', error);
            DatabaseService.hideLoading();
        });
},

    // Add new product
    addProduct: function(e) {
        e.preventDefault();
        
        DatabaseService.showLoading();
        
        const productData = {
            name: this.elements.addProductName.value,
            quantity: parseInt(this.elements.addProductQuantity.value),
            price: parseFloat(this.elements.addProductPrice.value)
        };
        
        DatabaseService.addProduct(productData)
            .then(() => {
                this.refreshData();
                this.closeAddModal();
                this.showSuccessNotification();
            })
            .catch(error => {
                console.error('Error adding product:', error);
                DatabaseService.hideLoading();
            });
    },

   // In UIController's deleteProduct method:
deleteProduct: function() {
    if (this.state.productToDelete) {
        DatabaseService.showLoading();
        
        DatabaseService.deleteProduct(this.state.productToDelete)
            .then(() => {
                this.refreshData(true); // Show loading for user-initiated refresh
                this.closeDeleteModal();
                this.state.productToDelete = null;
            })
            .catch(error => {
                console.error('Error deleting product:', error);
                DatabaseService.hideLoading();
            });
    }
},

    // Toggle sidebar on mobile
    toggleSidebar: function() {
        if (this.elements.sidebar) {
            this.elements.sidebar.classList.toggle('show');
        }
    },

    // Close sidebar
    closeSidebar: function() {
        if (this.elements.sidebar) {
            this.elements.sidebar.classList.remove('show');
        }
    },

    // Toggle user dropdown
    toggleUserDropdown: function() {
        if (this.elements.dropdownContent) {
            this.elements.dropdownContent.classList.toggle('show');
        }
    },

    // Close dropdown when clicking outside
    closeDropdowns: function(event) {
        if (!event.target.closest('.user-menu') && this.elements.dropdownContent) {
            this.elements.dropdownContent.classList.remove('show');
        }
    },

    // Handle scroll events
    handleScroll: function() {
        if (!this.elements.floatingBtn) return;
        
        if (window.innerWidth > 576) {
            this.elements.floatingBtn.classList.remove('visible');
            return;
        }
        
        if (window.scrollY > 300) {
            this.elements.floatingBtn.classList.add('visible');
        } else {
            this.elements.floatingBtn.classList.remove('visible');
        }
    },

    // Scroll to top
    scrollToTop: function() {
        window.scrollTo({
            top: 0,
            behavior: 'smooth'
        });
    },

    // Handle sign out
handleSignOut: function(e) {
    e.preventDefault();
    DatabaseService.showLoading();
    
    setTimeout(() => {
        // Clear all authentication-related data
        localStorage.removeItem('isAuthenticated');
        localStorage.removeItem('userCredentials');
        localStorage.removeItem('vendingMachineBinId');
        localStorage.removeItem('vendingMachineData');
        
        // Redirect to login page with cache-busting to prevent back button issues
        window.location.replace('index.html');
    }, 1500);
},

    // Show error message
    showError: function(message) {
        if (this.elements.productsContainer) {
            this.elements.productsContainer.innerHTML = `
                <div class="error-message">
                    <i class="fas fa-exclamation-triangle"></i>
                    <p>${message}</p>
                </div>
            `;
        }
    },

    // Setup scroll listener
    setupScrollListener: function() {
        window.addEventListener('scroll', this.handleScroll.bind(this));
        window.addEventListener('load', this.handleScroll.bind(this));
    },

    // Setup event listeners
    setupEventListeners: function() {
        // Search functionality
        if (this.elements.searchInput) {
            this.elements.searchInput.addEventListener('input', this.searchProducts.bind(this));
        }
        
        // Form submissions
        if (this.elements.editForm) {
            this.elements.editForm.addEventListener('submit', this.saveProduct.bind(this));
        }
        
        if (this.elements.addForm) {
            this.elements.addForm.addEventListener('submit', this.addProduct.bind(this));
        }
        
        // Delete confirmation
        if (this.elements.confirmDeleteBtn) {
            this.elements.confirmDeleteBtn.addEventListener('click', this.deleteProduct.bind(this));
        }
        
        // Add Product button
        if (this.elements.addProductBtn) {
            this.elements.addProductBtn.addEventListener('click', this.openAddProductModal.bind(this));
        }
        
        // UI interactions
        if (this.elements.hamburgerMenu) {
            this.elements.hamburgerMenu.addEventListener('click', this.toggleSidebar.bind(this));
        }
        
        if (this.elements.sidebarCloseBtn) {
            this.elements.sidebarCloseBtn.addEventListener('click', this.closeSidebar.bind(this));
        }
        
        if (this.elements.userIcon) {
            this.elements.userIcon.addEventListener('click', this.toggleUserDropdown.bind(this));
        }
        
        document.addEventListener('click', this.closeDropdowns.bind(this));
        
        // Floating button
        if (this.elements.floatingBtn) {
            this.elements.floatingBtn.addEventListener('click', this.scrollToTop.bind(this));
        }
        
        // Sign out
        if (this.elements.signOutLink) {
            this.elements.signOutLink.addEventListener('click', this.handleSignOut.bind(this));
        }
        
        if (this.elements.changeAvatarLink) {
        this.elements.changeAvatarLink.addEventListener('click', (e) => {
            e.preventDefault();
            this.elements.avatarUpload.click();
        });
    }
    
    if (this.elements.avatarUpload) {
        this.elements.avatarUpload.addEventListener('change', (e) => {
            this.handleAvatarUpload(e);
        });
    }

      // In DatabaseService's setupNetworkListeners:
window.addEventListener('online', () => {
    this.isOnline = true;
    console.log('Network connection restored - syncing changes');
    this.fetchProducts().then(() => {
        UIController.refreshData(false); // Background sync
    });
});
        // Delegate edit and delete buttons
        if (this.elements.productsContainer) {
            this.elements.productsContainer.addEventListener('click', (e) => {
                
                const editBtn = e.target.closest('.btn-edit');
                const deleteBtn = e.target.closest('.btn-delete');
                
                if (editBtn) {
                    this.openEditModal(parseInt(editBtn.dataset.id));
                }
                
                if (deleteBtn) {
                    this.showDeleteModal(parseInt(deleteBtn.dataset.id));
                }
                
            });
        }

    }
};

const AppController = {
    init: function() {
        // Initialize the UI immediately
        UIController.init();
        this.setupEventListeners();
        this.setupScrollListener();
        this.setupNetworkStatus();
        
        // Initialize the profile bin
        UserProfileService.initProfileBin().catch(error => {
            console.error('Profile bin initialization error:', error);
        });
        
        // Load user info and avatar
        this.loadUserInfo();
        
        // Setup network listeners
        DatabaseService.setupNetworkListeners();
    }
};


// Set initial body style to prevent white flash
document.body.style.visibility = 'hidden';
    </script>
    
</body>
</html>